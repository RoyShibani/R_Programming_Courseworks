---
title: "Linear Regression"
author: "Shibani Roy (Banner ID - 904146654)"
date: "2024-09-24"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



## Overview - Linear Regression

In statistics, linear regression is used to model a relationship between a continuous dependent variable and one or more independent variables. The independent variable can be either categorical or numerical. The case when we have only **one independent variable** then it is called as **simple linear regression**. If we have **more than one independent variable**, then it is called as **multivariate regression**.

A mathematical representation of a linear regression model is as give below:

Y = $\beta$_0+ $\beta$_1X_1+ $\beta$_2X_2+$\beta$_3X_3+....+$\beta$_nX_n+error

In the above equation, $Œ≤$_0 coefficient represents **intercept** and $Œ≤$_i coefficient represents **slope**. Here we will be using a case study approach to help you understand the linear regression algorithm.

The data `expenses.csv` collects information on health insurance beneficiaries, including medical costs billed by the health insurance companies. More specifically, the data contains the following variables:


-age: age of primary beneficiary

-sex: insurance contractor sex (female, male)

-bmi: body mass index based on ratio of mass to height squared (ùëòùëî/ùëö2)

-children: number of children covered by health insurance / number of dependents

-smoker: is the beneficiary a smoker

-region: the beneficiary‚Äôs residential area in the US: northeast, southeast, southwest, northwest.

-charges: individual medical costs billed by health insurance

In the below case study, we will be using`expenses.csv` to predict the medical costs. Let us look at the top six observations of **expenses.csv**.

```{r , echo=T}
##Reading data
setwd ("/Users/shibaniroy/Documents/GitHub/HW_1-Group-9")
medicalcosts <- read.csv("/Users/shibaniroy/Documents/GitHub/HW_1-Group-9/expenses.csv" )

#Print top 6 observations
head(medicalcosts)
```

## Exploratory Data Analysis

Exploratory data analysis exercise is critical to any project related to Machine Learning. It is an approach to understand and summarize the main characteristics of a given data. Mostly, this involves slicing and dicing of data at different levels, and results are often presented with visual methods. If done correctly, it can reveal many aspects of the data, which will surely help you build better models.

Every data set is different, and thus, it isn‚Äôt easy to list down steps one should perform as part of data exploration. However, the key to a successful EDA is to keep asking the questions which one believes helps in solving the business problem or put across all sorts of hypothesis and then testing them using appropriate statistical tests.

In other words, try to figure if there is a statistically significant relationship between the target and independent variables. What are the things which derive target variables?

Below are few things which we should consider exploring from the statistical point of view:

**1. Checking distribution of target variable ‚Äì **First, you should always try to understand the nature of your target variable. To achieve this, we will be drawing a histogram with a density plot.

```{r, echo=T}
##Checking distribution of target variable
library(ggplot2)
#Building histogram
ggplot(data=medicalcosts, aes(charges)) +
  geom_histogram(aes(y = after_stat(density)), fill = "orange") +
  geom_density()
```

**2. Analyzing Summary Statistics ‚Äì** Here, we will simply create summary statistics for all the variables to understand the behavior of all the independent variables.

Both missing values and outliers are of concern for Machine Learning models as they tend to push the result towards extreme values.

```{r, echo=T}
# loading psych package
library(psych)
psych::describe(medicalcosts)
```

**3. Checking Outliers Using Boxplots -** Here are using a boxplot for plotting the distribution of each numerical variable to check for outliers. 

If points lie beyond whispers, then we have outlier values present. For now, we are just going by univariate outlier analysis.

If outliers are present, then you must either remove or do a proper treatment before moving forward.

```{r, echo=T}
library(reshape)
meltData <- melt(medicalcosts)
p <- ggplot(meltData, aes(factor(variable), value))
p + geom_boxplot() + facet_wrap(~variable, scale="free")
```

**4. Correlation Matrix Visualization ‚Äì **We will use corrgram package to visualize and analyze the correlation matrix. In theory, the correlation between the independent variables should be zero. In practice, we expect and are okay with weak to no correlation between independent variables.

We also expect that independent variables reflect a high correlation with the target variable.

```{r, echo=T}
require(corrgram)
corrgram(medicalcosts, order=TRUE)
```


## Training Regression Model


To build a linear regression, we will be using `lm()` function. The function takes two main arguments.

- **Formula** stating the dependent and independent variables separated by ~(tilder).
- The **dataset** name.
- There are other useful arguments and thus would request you to use `help(lm)` to read more from the documentation.

### Diving data into train and test subsets

The expenses.csv data is divided into 70:30 split of train and test. The 70:30 split is the most common and is mostly used during the training phase. 70% of the data is used for training, and the rest 30% is for testing how good we were able to learn the data behavior.

```{r}
library(caret)
# Split data into train and test
index <- createDataPartition(medicalcosts$charges, p = .70, list = FALSE)
train <- medicalcosts[index, ]
test <- medicalcosts[-index, ]


# Checking the dim of train
dim(train)
```

**You can see we have 70% of the random observations in the training dataset.**

### Building Model


```{r}
# Taining model
lmModel <- lm(charges ~ . , data = train)
# Printing the model object
print(lmModel)
```

**Interpreting Regression Coefficients**
In the above output, **Intercept** represents that the minimum value of Charges that will be received, if all the variables are constant or absent.

**Please note**

Intercept may not always make sense in business terms.

**Slope(represented by independent variables)** tells us about the rate of change that the Price variable will witness, with every one unit change in the independent variable.

## Validating Regression Coefficients and Models

We must ensure that the value of each beta coefficient is significant and has not come by chance. In R, the `lm` function runs a **one-sample t-test** against each beta coefficient to ensure that they are significant and have not come by chance. Similarly, we need to validate the overall model. Just like a one-sample t-test, `lm` function also generates three statistics, which help data scientists to validate the model. These statistics include **R-Square**, **Adjusted R-Square**, and **F-test**, also known as global testing.

To view these statistics, we need to pass the `lmModel` object to the `summary()` function.

```{r}
# Checking model statistics
summary(lmModel)
```

In the above output, **Pr(>|t|)** represents the p-value, which can be compared against the alpha value of 0.05 to ensure if the corresponding beta coefficient is significant or not. The `lm` function here lends a helping hand. All values in the output that have (.) period or (*) astric against the variable names indicates that these values are significant. Based upon this, we now know that all variables are statistically significant except **sexmale**, **regionnorthwest**.

For overall model accuracy, let‚Äôs discuss statistics generated by `lm` function one by one.

**1. Multiple R-squared: 0.752 ‚Äì** The R-squared value is formally called a coefficient of determination. Here, 0.752 indicates that the intercept, age, sexmale, bmi,children, smokeryes, regionnorthwest, regionsoutheast, regionsouthwest, when put together, are able to explain 75.2% of the variance in the Price variable. The value of R-squared lies between 0 to 1. In practical applications, if the R2 value is higher than 0.70, we consider it a good model.

**2. Adjusted R-squared: 0.7498 ‚Äì** The Adjusted R-squared value tells if the addition of new information ( variable ) brings significant improvement to the model or not. So as of now, this value does not provide much information. However, the increase in the adjusted R-squared value with the addition of a new variable will indicate that the variable is useful and brings significant improvement to the model.

**A large difference between the R-Squared and Adjusted R-squared is not appreciated and generally indicates that multicollinearity exists within the data.**

**3. F-statistic: 355.4 on 8 and 929 DF, p-value: < 2.2e-16 ‚Äì** This line talks about the global testing of the model. The `lm` function runs an ANOVA test to check the significance of the overall model. Here the null hypothesis is that the model is not significant, and the alternative is that the model is significant. According to the p-values < 0.05, our model is significant.

Albeit, looking at these statistics is enough to take a call on the model significance. But there are other validation methods for linear regression that can be of help while deciding how good or bad the model is. Some of them are mentioned below:


**4. AIC and BIC values ‚Äì** The AIC(Akaike‚Äôs information criterion, 1974) and BIC(Bayesian information criterion, 1978) are penalized-likelihood criteria. Both these measures use a ‚Äúmeasure of fit + complexity penalty‚Äù to get the final values.

AIC = ‚Äì 2 * ln(likelihood) + 2 * p

BIC = ‚Äì 2 * ln(likelihood) + ln(N) * p

Here p = number of estimated parameters and N = sample size.

The AIC and BIC values can be used for choosing the best predictor subsets in regression and for comparing different models. When comparing different models, the model with minimum AIC and BIC values is considered the best model.

**Note**

AIC is likely to overfit the data, whereas BIC is susceptible to underfit the data.

```{r, echo=T}
# Using AIC function
AIC(lmModel)
# Using BIC function
BIC(lmModel)  
```


**5. Root Mean Square Error(RMSE) ‚Äì** By comparing the RMSE statistics of different models, we can decide which is a better model. The model with the lower RMSE value is considered a better model. There are other similar functions like MAE, MAPE, MSE, and so on that can be used. These functions can be found in `Metrics` R Package. These functions take majorly two arguments: One is the actual value and second, predicted values. So let‚Äôs see how we can get these values. The actuals can be 100% found from the original dataset or the training data in our case. However, to find the fitted values, we need to explore the model object.

```{r, echo=T}
# Checking model object for actual and predicted values
names(lmModel)
```

The above vector presents the names of the object that constitute the model object. Here, fitted values are the predicted values. Now, we will use these values to generate the **rmse** values.

```{r, echo= T}
library(Metrics)
rmse(actual = train$charges, predicted = lmModel$fitted.values)
```

## Checking Assumptions of Linear Regression

Linear regression is parametric, which means the algorithm makes some assumptions about the data. A linear regression model is only deemed fit is these assumptions are met. There are about some assumptions and are mentioned below. If the model fails to meet these assumptions, then we simply cannot use this model.

**1. Errors should follow normal distribution ‚Äì** This can be checked by drawing a histogram of residuals or by using `plot()` function. The `plot` function creates 4 different charts. One of which is an NPP plot. The chart confirms if the errors follow a normal distribution or not.

### Generating histogram
```{r, echo = T}
# Histogram to check the distribution of errors
hist(lmModel$residuals)
```

```{r, echo=T}
plot(lmModel)
```

**2. There should be no heteroscedasticity ‚Äì** This means that the variance of error terms should be constant. We shall not see any patterns when we draw a plot between residuals and fitted values. And the mean line should be close to Zero.

### Generating the scatterplot between residuals and fitted values

```{r, echo=T}
# Using plot function
plot(lmModel)
```

checking heteroskedasticity in r

A straight red line closer to the zero value represents that we do not have heteroscedasticity problem in our data.

**3. There should be no auto serial correlation ‚Äì** The autocorrelation means that error terms should not be correlated with each other. To check this, we can run the Durbin-Watson test(dw test). The test returns a value between 0 and 4. If the value is two, we say there is no auto serial correlation. However, a value higher than 2 represents (-) ve correlation and value lower than 2 represents (+) ve correlation.

```{r, echo=T}
library("lmtest")
dwtest(lmModel)
```

We got a value of 2.0146 which suggests that there is auto serial correlation.

### Predicting Dependent Variable(Y) in Test Dataset

We test the model performance on test data set to ensure that our model is stable, and we get the same or closer enough results to use this trained model to predict and forecast future values of dependent variables. To predict, we use predict function, and then we generate R-Squared value to see if we get the same result as we got in the training dataset or not.

```{r, echo=T}
# Predicting Charges in test dataset
test$PreditedCharges <- predict(lmModel, test)

# Priting top 6 rows of actual and predited charges
head(test[ , c("charges", "PreditedCharges")])

```

### Generating R-Squared Value for the test dataset

We are using a user-defined formula to generate the R-Squared value here.

```{r, echo=T}
actual <- test$charges
preds <- test$PreditedCharges
rss <- sum((preds - actual) ^ 2)
tss <- sum((actual - mean(actual)) ^ 2)
rsq <- 1 - rss/tss
rsq
```

**Our model is performing good and have strong relationship between the dependent variable and the independent variables**.

In the test dataset, we got an accuracy of **0.7644622** and a training data set, we got an accuracy of **0.7447**.





























































